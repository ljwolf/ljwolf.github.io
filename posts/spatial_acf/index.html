<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1"><title>Spatial Autocorrelation Functions - Yet Another Geographer</title>
<meta property="og:title" content="Spatial Autocorrelation Functions - Yet Another Geographer">
<meta property="og:type" content="article">


<meta property="og:image" content="images/main.jpg">

<meta property="og:url" content="https://ljwolf.org/posts/spatial_acf/"><meta property="og:description" content="">
<meta name="Description" property="description" content="">
<link rel="me" href="https://twitter.com/@levijohnwolf">
<meta name="twitter:card" content="summary">
<meta name="twitter:site" content="@levijohnwolf">
<meta name="twitter:creator" content="@levijohnwolf">



<meta property="keywords" content ="spatial autocorrelation, esda, dissertation, swing, elections">



<link rel="stylesheet" href="https://ljwolf.org/css/style.min.css">

<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/svg+xml" href="/favicon.svg">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/site.webmanifest">
<link href="https://ljwolf.org/index.xml" type="application/atom+xml" rel="alternate" title="Sitewide Atom feed" />
<meta name="theme-color" content="#ffffff">


<script>function updateMode(){localStorage.theme==="dark"||!("theme"in localStorage)&&window.matchMedia("(prefers-color-scheme: dark)").matches?document.documentElement.classList.add("dark"):document.documentElement.classList.remove("dark")}function toggleMode(){localStorage.theme==="dark"?localStorage.theme="light":localStorage.theme="dark",updateMode()}window.onload=updateMode();function toggleMenu(){let e=document.getElementById("navbar-default");e.classList.contains("hidden")?e.classList.remove("hidden"):e.classList.add("hidden")}</script>

  </head>
  <body>
    <header class="md:px-0 px-2">
        <nav >
  <div class="container flex flex-wrap justify-between items-center mx-auto">
    <div class="nav-main my-2.5">
      <a href="https://ljwolf.org/" class="nav-title py-2.5 text-2xl
               text-zinc-600 dark:text-zinc-300 hover:border-b-0">Yet Another Geographer</a>
    </div>
    <button type="button"
            onclick="toggleMenu()"
            class="inline-flex items-center p-2 ml-3
                  text-sm text-gray-500
                  rounded-lg md:hidden hover:bg-gray-100
                  focus:outline-none focus:ring-2
                  focus:ring-gray-200 dark:text-gray-400
                  dark:hover:bg-gray-700 dark:focus:ring-gray-600"
            aria-controls="navbar-default"
            aria-expanded="false">
        <span class="sr-only">Open main menu</span>
        <svg class="w-6 h-6" aria-hidden="true" fill="currentColor"
             viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
          <path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1
                           0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0
                           01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0
                           01-1-1z" clip-rule="evenodd"></path>
        </svg>
    </button>
    <div class="hidden w-full md:block md:w-auto" id="navbar-default">
      <ul class="grid md:grid-flow-col items-center justify-between text-lg
                 my-2.5 grid-cols-1 pl-0 text-center">
        
        <li class="p-2.5 md:first:pl-0 md:border-none border-b dark:border-zinc-500 list-none">
          <a class="text-zinc-600 dark:text-zinc-300
                    hover:border-b-0" href="https://orcid.org/0000-0003-0274-599X">ORCID</a>
        </li>
        
        <li class="p-2.5 md:first:pl-0 md:border-none border-b dark:border-zinc-500 list-none">
          <a class="text-zinc-600 dark:text-zinc-300
                    hover:border-b-0" href="https://github.com/ljwolf">GitHub</a>
        </li>
        
        <li class="p-2.5 md:first:pl-0 md:border-none border-b dark:border-zinc-500 list-none">
          <a class="text-zinc-600 dark:text-zinc-300
                    hover:border-b-0" href="https://www.dropbox.com/s/y5mjkduq7bopzex/currvita.pdf?dl=0">CV</a>
        </li>
        
        <li class="p-2.5 md:first:pl-0 md:border-none border-b dark:border-zinc-500 list-none">
          <a class="text-zinc-600 dark:text-zinc-300
                    hover:border-b-0" href="/posts/">Blog</a>
        </li>
        
        <li class="p-2.5 md:first:pl-0 md:border-none border-b dark:border-zinc-500 list-none">
          <a class="text-zinc-600 dark:text-zinc-300
                    hover:border-b-0" href="https://geographicdata.science/book">GDS Python</a>
        </li>
        
        <li class="p-2.5 md:first:pl-0 md:border-none border-b dark:border-zinc-500 list-none">
          <a class="text-zinc-600 dark:text-zinc-300
                    hover:border-b-0" href="/rasa/">RASA</a>
        </li>
        
        <li class="h-7 pl-2.5 pr-0 list-none">
          <button type="button" onclick="toggleMode()" class="h-full"  aria-label="Toggle between dark and light mode">
            <img class="h-7 w-7 max-h-full mb-1.5 p-1.5 hidden dark:inline"
                 id="ligh-mode-button-img"
                 alt="A sun icon for switching to light mode"
                 src="https://ljwolf.org/img/light_mode.svg">
            <img class="h-7 w-7 max-h-full mb-1.5 p-1.5 inline dark:hidden"
                 id="dark-mode-button-img"
                 alt="A moon icon for switching to dark mode"
                 src="https://ljwolf.org/img/dark_mode.svg">
          </button>
        </li>
      </ul>
    </div>
  </div>
</nav>


    </header>
    <main class="content h-card container mt-2 m-auto
                 leading-loose md:px-0 px-2 z-0"
          role="main">
    
<article class="article h-entry" itemprop="mainEntity" itemscope itemtype="http://schema.org/BlogPosting">
    <div class="title-container">
        <h1 class="article-title p-name" itemprop="name">Spatial Autocorrelation Functions</h1>
        
        <div class="flex justify-between items-center">
            
            <a class="text-lg text-gray-600 dark:text-gray-400 border-none u-url" href="https://ljwolf.org/posts/spatial_acf/">
                <time itemprop="datePublished" class="dt-published"
                    datetime="2018-03-09T17:34:20Z"
                    content="2018-03-09T17:34:20Z">
                    2018.03.09
                </time>
            </a>
            
            
                
                <a class="text-gray-600 dark:text-gray-400 text-right border-none p-author h-card" rel="author" href="https://ljwolf.org/" itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">Levi John Wolf</span></a>
                
            
        </div>
        
    </div>

    <div class="article-content e-content" itemprop="articleBody">
        <p>I looked into using spatial autocorrelation functions in my dissertation to characterize the ``scale&rsquo;&rsquo; at which processes operate electorally.
I did an analysis of presidential vote by county, trying to identify where, exactly, clusters of votes tend to become decorrelated.
The typical diameter at which the so-called &ldquo;spatial autocorrelation function&rdquo; goes to zero denotes how wide a typical spatial cluster might be,
and the partial spatial autocorrelation function gives an anticipated order at which spatial autocorrelation may hold.</p>
<p>This will be published along with my dissertation when it becomes unembargoed. I also gave a talk on this in the <a href="https://docs.google.com/presentation/d/1JHbZ1gQTgQ-v9x09udPhfxDGfxNyWo39qRYCogGchHU/edit?usp=sharing">2017 AAG</a>. So, below is the initial exploration of what a spatial autocorrelation/partial autocorrelation function might look like.</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">import</span> <span style="color:#447fcf;text-decoration:underline">pysal</span> <span style="color:#6ab825;font-weight:bold">as</span> <span style="color:#447fcf;text-decoration:underline">ps</span>
</span></span><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">import</span> <span style="color:#447fcf;text-decoration:underline">numpy</span> <span style="color:#6ab825;font-weight:bold">as</span> <span style="color:#447fcf;text-decoration:underline">np</span>
</span></span><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">import</span> <span style="color:#447fcf;text-decoration:underline">geopandas</span> <span style="color:#6ab825;font-weight:bold">as</span> <span style="color:#447fcf;text-decoration:underline">gpd</span>
</span></span><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">import</span> <span style="color:#447fcf;text-decoration:underline">pandas</span> <span style="color:#6ab825;font-weight:bold">as</span> <span style="color:#447fcf;text-decoration:underline">pd</span>
</span></span><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">import</span> <span style="color:#447fcf;text-decoration:underline">matplotlib.pyplot</span> <span style="color:#6ab825;font-weight:bold">as</span> <span style="color:#447fcf;text-decoration:underline">plt</span>
</span></span><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">import</span> <span style="color:#447fcf;text-decoration:underline">seaborn</span> <span style="color:#6ab825;font-weight:bold">as</span> <span style="color:#447fcf;text-decoration:underline">sns</span>
</span></span><span style="display:flex;"><span>sns.set_style(<span style="color:#ed9d13">&#39;white&#39;</span>)
</span></span><span style="display:flex;"><span>%matplotlib inline
</span></span></code></pre></div><p>To talk about the spatial (partial) autocorrelation function, which is kind of like a mixture in concept between the geostatistical variogram and the (partial) autocorrelation function in time series analysis, let&rsquo;s use presidential vote choice results at the county level for 2008, 2012, and 2016.</p>
<p>To do this, I&rsquo;ll first grab the results from a github repo I&rsquo;ve been tracking. Thanks to user <a href="https://github.com/tonmcg">@tonmcg</a> for making this available in plaintext, so we can grab it using pandas without downloading it.</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>votes = pd.read_csv(<span style="color:#ed9d13">&#39;https://raw.githubusercontent.com/tonmcg/&#39;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#ed9d13">&#39;County_Level_Election_Results_12-16/master/&#39;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#ed9d13">&#39;US_County_Level_Presidential_Results_08-16.csv&#39;</span>)
</span></span></code></pre></div><p>Since the spatial autocorrelation function (and variogram) are related to the <em>spatial positions</em> of our data (or, in the least, a topological arrangement of our data), we need to merge these county-level results with the actual geometries of each county. To do this, I&rsquo;ll use the example county dataset in PySAL, <a href="https://github.com/pysal/pysal">the Python spatial analysis library</a>.</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>geoms = gpd.read_file(ps.examples.get_path(<span style="color:#ed9d13">&#39;NAT.shp&#39;</span>))
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>votes.head()
</span></span></code></pre></div><!-- raw HTML omitted -->
<p>Then, to merge things up, I&rsquo;ll create a common key based on the FIPS code of the county and merge the data</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>votes[<span style="color:#ed9d13">&#39;FIPS&#39;</span>] = votes.fips_code.apply(<span style="color:#6ab825;font-weight:bold">lambda</span> x: <span style="color:#24909d">str</span>(x).rjust(<span style="color:#3677a9">5</span>,<span style="color:#ed9d13">&#39;0&#39;</span>))
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>votes = pd.merge(votes, geoms[[<span style="color:#ed9d13">&#39;FIPS&#39;</span>, <span style="color:#ed9d13">&#39;STATE_NAME&#39;</span>, <span style="color:#ed9d13">&#39;geometry&#39;</span>]], how=<span style="color:#ed9d13">&#39;right&#39;</span>, on=<span style="color:#ed9d13">&#39;FIPS&#39;</span>)
</span></span><span style="display:flex;"><span>votes = gpd.GeoDataFrame(votes)
</span></span></code></pre></div><p>Finally, since I&rsquo;m mostly interested in two-party vote shares, rather than raw votes, I&rsquo;ll construct the two party vote share in each year as:</p>
<p>\[ tpv_{it} = \frac{d_{it}}{d_{it} + r_{it}} \]</p>
<p>where (d_{it}) is raw vote cast in county (i) for the Democrat candidate in time (t), and (r_{it}) is the comparable raw vote cast for the Republican candidate. We can just do simple series operations to get this done:</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>votes[<span style="color:#ed9d13">&#39;tpv_2008&#39;</span>] = votes.dem_2008 / (votes.dem_2008 + votes.gop_2008)
</span></span><span style="display:flex;"><span>votes[<span style="color:#ed9d13">&#39;tpv_2012&#39;</span>] = votes.dem_2012 / (votes.dem_2012 + votes.gop_2012)
</span></span><span style="display:flex;"><span>votes[<span style="color:#ed9d13">&#39;tpv_2016&#39;</span>] = votes.dem_2016 / (votes.dem_2016 + votes.gop_2016)
</span></span></code></pre></div><p>These distributions tend to appear Gaussian, if not a slightly skewed Gaussian. But, we&rsquo;re not really making any distributional analyses (like we were in my <a href="http://ljwolf.org/post/153806452919/a-short-exploration-of-the-2016-electoral-swing">exploratory spatial regression notebook</a>), so I&rsquo;ll let this sit for now.</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>f,ax = plt.subplots(<span style="color:#3677a9">1</span>,<span style="color:#3677a9">3</span>, figsize=(<span style="color:#3677a9">2</span>*<span style="color:#3677a9">3</span>*<span style="color:#3677a9">1.6</span>, <span style="color:#3677a9">2</span>))
</span></span><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">for</span> i,col <span style="color:#6ab825;font-weight:bold">in</span> <span style="color:#24909d">enumerate</span>([<span style="color:#ed9d13">&#39;tpv_2008&#39;</span>,<span style="color:#ed9d13">&#39;tpv_2012&#39;</span>,<span style="color:#ed9d13">&#39;tpv_2016&#39;</span>]):
</span></span><span style="display:flex;"><span>    sns.kdeplot(votes[col].values, shade=<span style="color:#6ab825;font-weight:bold">True</span>, color=<span style="color:#ed9d13">&#39;slategrey&#39;</span>, ax=ax[i])
</span></span><span style="display:flex;"><span>    ax[i].set_title(col.split(<span style="color:#ed9d13">&#39;_&#39;</span>)[<span style="color:#3677a9">1</span>])
</span></span></code></pre></div><pre><code>/home/ljw/anaconda3/envs/py3/lib/python3.5/site-packages/statsmodels/nonparametric/kde.py:454: RuntimeWarning: invalid value encountered in greater
  X = X[np.logical_and(X&gt;clip[0], X&lt;clip[1])] # won't work for two columns.
/home/ljw/anaconda3/envs/py3/lib/python3.5/site-packages/statsmodels/nonparametric/kde.py:454: RuntimeWarning: invalid value encountered in less
  X = X[np.logical_and(X&gt;clip[0], X&lt;clip[1])] # won't work for two columns.
/home/ljw/anaconda3/envs/py3/lib/python3.5/site-packages/statsmodels/nonparametric/kdetools.py:20: VisibleDeprecationWarning: using a non-integer number instead of an integer will result in an error in the future
  y = X[:m/2+1] + np.r_[0,X[m/2+1:],0]*1j
</code></pre>
<p><img src="images/spacf_output_12_1.png" alt="png"></p>
<p>Next, since I&rsquo;ll be mapping our data, I&rsquo;ll use <a href="https://github.com/geopandas/geopandas">geopandas</a> to reproject the raw data from PySAL (in Plate Caree projection) into a better projection for choropleth mapping, the Albers Equal Area Conic projection:</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>votes.crs = {<span style="color:#ed9d13">&#39;init&#39;</span>:<span style="color:#ed9d13">&#39;epsg:4326&#39;</span>}
</span></span><span style="display:flex;"><span>votes = votes.to_crs(epsg=<span style="color:#ed9d13">&#39;5070&#39;</span>)
</span></span></code></pre></div><p>Now, before we get any further, let&rsquo;s make some maps of the two-party vote shares in 2008, 2012, and 2016 (alongside the vote distributions), and explore what spatial distribution dynamics might be going on:</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>f,ax = plt.subplots(<span style="color:#3677a9">3</span>,<span style="color:#3677a9">2</span>, figsize=(<span style="color:#3677a9">1.6</span>*<span style="color:#3677a9">6</span> + <span style="color:#3677a9">1</span>,<span style="color:#3677a9">6</span>*<span style="color:#3677a9">3</span>), gridspec_kw=<span style="color:#24909d">dict</span>(width_ratios=(<span style="color:#3677a9">6</span>,<span style="color:#3677a9">1</span>)))
</span></span><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">for</span> i,col <span style="color:#6ab825;font-weight:bold">in</span> <span style="color:#24909d">enumerate</span>([<span style="color:#ed9d13">&#39;tpv_2008&#39;</span>,<span style="color:#ed9d13">&#39;tpv_2012&#39;</span>,<span style="color:#ed9d13">&#39;tpv_2016&#39;</span>]):
</span></span><span style="display:flex;"><span>    votes.plot(col, linewidth=<span style="color:#3677a9">.05</span>, cmap=<span style="color:#ed9d13">&#39;RdBu&#39;</span>, ax=ax[i,<span style="color:#3677a9">0</span>])
</span></span><span style="display:flex;"><span>    ax[i,<span style="color:#3677a9">0</span>].set_title(col.split(<span style="color:#ed9d13">&#39;_&#39;</span>)[<span style="color:#3677a9">1</span>] + <span style="color:#ed9d13">&#39; Two Party Vote (% Dem)&#39;</span>)
</span></span><span style="display:flex;"><span>    ax[i,<span style="color:#3677a9">0</span>].set_xticklabels(<span style="color:#ed9d13">&#39;&#39;</span>)
</span></span><span style="display:flex;"><span>    ax[i,<span style="color:#3677a9">0</span>].set_yticklabels(<span style="color:#ed9d13">&#39;&#39;</span>)
</span></span><span style="display:flex;"><span>    sns.kdeplot(votes[col].values, ax=ax[i,<span style="color:#3677a9">1</span>], vertical=<span style="color:#6ab825;font-weight:bold">True</span>, shade=<span style="color:#6ab825;font-weight:bold">True</span>, color=<span style="color:#ed9d13">&#39;slategrey&#39;</span>)
</span></span><span style="display:flex;"><span>    ax[i,<span style="color:#3677a9">1</span>].set_xticklabels(<span style="color:#ed9d13">&#39;&#39;</span>)
</span></span><span style="display:flex;"><span>    ax[i,<span style="color:#3677a9">1</span>].set_ylim(<span style="color:#3677a9">0</span>,<span style="color:#3677a9">1</span>)
</span></span><span style="display:flex;"><span>f.tight_layout()
</span></span><span style="display:flex;"><span>plt.show()
</span></span></code></pre></div><pre><code>/home/ljw/anaconda3/envs/py3/lib/python3.5/site-packages/statsmodels/nonparametric/kde.py:454: RuntimeWarning: invalid value encountered in greater
  X = X[np.logical_and(X&gt;clip[0], X&lt;clip[1])] # won't work for two columns.
/home/ljw/anaconda3/envs/py3/lib/python3.5/site-packages/statsmodels/nonparametric/kde.py:454: RuntimeWarning: invalid value encountered in less
  X = X[np.logical_and(X&gt;clip[0], X&lt;clip[1])] # won't work for two columns.
/home/ljw/anaconda3/envs/py3/lib/python3.5/site-packages/statsmodels/nonparametric/kdetools.py:20: VisibleDeprecationWarning: using a non-integer number instead of an integer will result in an error in the future
  y = X[:m/2+1] + np.r_[0,X[m/2+1:],0]*1j
</code></pre>
<p><img src="images/spacf_output_16_1.png" alt="png"></p>
<p>One thing that&rsquo;s super clear when you do these maps of two-party vote is that more counties tend to vote Republican than Democrat. In the KDE plots, you see this as the mode of the vote share distribution is well below .5, even in 2012, when President Obama won reelection handily. While the best analysis might be to drill all the way down to the voter tabulation district level, that data <em>attached</em> to its geographies is pretty hard to find, and often to large for most to work with on a national scale. I&rsquo;ve been working on putting it together in an sqlite dump, but that takes time :)</p>
<p>The second thing that&rsquo;s clear is that the collapse of the &ldquo;blue wall,&rdquo; Minnesota, Wisconsin, Michigan, looks like it was actually a gradual process at the county level. Lots of marginally-blue counties flipped, resulting in a statewide flip. As a geographer, another thing that&rsquo;s interesting about the electoral mosaic is almost how indistinguishably rural Illinois is from its surrounding areas in MO and KY. I think (if I were to finish my PhD and move into some electoral modeling), I would <strong>seriously</strong> look into markov random field models (say a hierarchical SAR/CAR model) of this process, since the state-based hierarchical models like will miss this type of proximity-based correlation entirely.</p>
<h1 id="how-are-counties-related-in-time">How are counties related in time?</h1>
<p>This is a reasonable first question. It&rsquo;s well known that past two-party vote share tends to predict future two-party vote share quite well at an aggregate level and over all ranges of vote share. Of course, what really matters in the end are how well the <em>wins in each state</em> correlate over time, which is a different question. While we could address this with county-level vote, I&rsquo;m using the county-level data to look at distribution dynamics, so I&rsquo;ll let that slide for now.</p>
<p>First, we drop the counties where we&rsquo;re missing data:</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>votes.dropna(subset=[<span style="color:#ed9d13">&#39;tpv_2008&#39;</span>, <span style="color:#ed9d13">&#39;tpv_2012&#39;</span>, <span style="color:#ed9d13">&#39;tpv_2016&#39;</span>], inplace=<span style="color:#6ab825;font-weight:bold">True</span>)
</span></span></code></pre></div><p>And, if we make a scatterplot of the past vote (on X axes) and the future vote (on the Y axes), we see that the correlation is very strong, both when comparing 2008 vs. 2012 and 2012 vs. 2016.</p>
<p>However, what&rsquo;s also clear is that 2012 vs. 2016 has lower correlation, especially in the range of competitve counties (between ~.4 and ~.6). I&rsquo;ll be looking into competitve counties (and legislative seats) later.</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>f,ax = plt.subplots(<span style="color:#3677a9">1</span>,<span style="color:#3677a9">2</span>, figsize=(<span style="color:#3677a9">4</span>*<span style="color:#3677a9">2.1</span>,<span style="color:#3677a9">4</span>))
</span></span><span style="display:flex;"><span>votes[[<span style="color:#ed9d13">&#39;tpv_2008&#39;</span>, <span style="color:#ed9d13">&#39;tpv_2012&#39;</span>]].plot.scatter(<span style="color:#ed9d13">&#39;tpv_2008&#39;</span>, <span style="color:#ed9d13">&#39;tpv_2012&#39;</span>, ax=ax[<span style="color:#3677a9">0</span>])
</span></span><span style="display:flex;"><span>ax[<span style="color:#3677a9">0</span>].set_xlabel(<span style="color:#ed9d13">&#39;2008 Two Party Vote (% Dem)&#39;</span>)
</span></span><span style="display:flex;"><span>ax[<span style="color:#3677a9">0</span>].set_ylabel(<span style="color:#ed9d13">&#39;2012 Two Party Vote (% Dem)&#39;</span>)
</span></span><span style="display:flex;"><span>ax[<span style="color:#3677a9">0</span>].axis([<span style="color:#3677a9">0</span>,<span style="color:#3677a9">1</span>,<span style="color:#3677a9">0</span>,<span style="color:#3677a9">1</span>])
</span></span><span style="display:flex;"><span>r = np.corrcoef(votes[<span style="color:#ed9d13">&#39;tpv_2008&#39;</span>].values, votes[<span style="color:#ed9d13">&#39;tpv_2012&#39;</span>].values)[<span style="color:#3677a9">0</span>,<span style="color:#3677a9">1</span>]
</span></span><span style="display:flex;"><span>ax[<span style="color:#3677a9">0</span>].text(<span style="color:#3677a9">.6</span>,<span style="color:#3677a9">.2</span>, s=<span style="color:#ed9d13">r</span><span style="color:#ed9d13">&#39;$\rho = </span><span style="color:#ed9d13">{:.3f}</span><span style="color:#ed9d13">$&#39;</span>.format(r), fontsize=<span style="color:#3677a9">20</span>)
</span></span><span style="display:flex;"><span>votes[[<span style="color:#ed9d13">&#39;tpv_2012&#39;</span>, <span style="color:#ed9d13">&#39;tpv_2016&#39;</span>]].plot.scatter(<span style="color:#ed9d13">&#39;tpv_2012&#39;</span>, <span style="color:#ed9d13">&#39;tpv_2016&#39;</span>, ax=ax[<span style="color:#3677a9">1</span>])
</span></span><span style="display:flex;"><span>ax[<span style="color:#3677a9">1</span>].set_xlabel(<span style="color:#ed9d13">&#39;2012 Two Party Vote (% Dem)&#39;</span>)
</span></span><span style="display:flex;"><span>ax[<span style="color:#3677a9">1</span>].set_ylabel(<span style="color:#ed9d13">&#39;2016 Two Party Vote (% Dem)&#39;</span>)
</span></span><span style="display:flex;"><span>ax[<span style="color:#3677a9">1</span>].axis([<span style="color:#3677a9">0</span>,<span style="color:#3677a9">1</span>,<span style="color:#3677a9">0</span>,<span style="color:#3677a9">1</span>])
</span></span><span style="display:flex;"><span>r = np.corrcoef(votes[<span style="color:#ed9d13">&#39;tpv_2012&#39;</span>].values, votes[<span style="color:#ed9d13">&#39;tpv_2016&#39;</span>].values)[<span style="color:#3677a9">0</span>,<span style="color:#3677a9">1</span>]
</span></span><span style="display:flex;"><span>ax[<span style="color:#3677a9">1</span>].text(<span style="color:#3677a9">.6</span>,<span style="color:#3677a9">.2</span>, s=<span style="color:#ed9d13">r</span><span style="color:#ed9d13">&#39;$\rho = </span><span style="color:#ed9d13">{:.3f}</span><span style="color:#ed9d13">$&#39;</span>.format(r), fontsize=<span style="color:#3677a9">20</span>)
</span></span><span style="display:flex;"><span>f.tight_layout()
</span></span><span style="display:flex;"><span>plt.show()
</span></span></code></pre></div><p><img src="images/spacf_output_21_0.png" alt="png"></p>
<p>Since we only have two time periods, the autocorrelation plot of this would look rather uninteresting. I&rsquo;ve been working on this at the congressional district level over the 20th (and now 21st) centuries using some data I grabbed from the <a href="http://www.electiondataarchive.org/datacenter.html">CLEA</a>, mixed with a little <a href="http://www.icpsr.umich.edu/icpsrweb/ICPSR/studies/6311">ICPSR6311</a>, and merged with the <a href="http://cdmaps.polisci.ucla.edu">UCLA collection of congressional districts</a>, and hopefully getting released through the research cluster I work with at <a href="https://spatial.uchicago.edu/">UChicago</a>. Again, this all takes time, but the data is ready to go, so ask me if you&rsquo;re interested.</p>
<h3 id="how-about-in-space">How about in space?</h3>
<p>Of course, an interesting question also might be to look for clusters in vote. We know about rural/urban divides  and regional divides in American voting, so we would expect some pretty strong correlation between neighbors at a county level.</p>
<p>However, what&rsquo;s the <em>order</em> of this process? That is, how far away are counties related to one another?</p>
<p>This has a pretty clear analogue in time-series autocorrelation analysis. The autocorrelation function for a serially-correlated signal computes the correlation between the signal at time (t) and the signal at time (t-k), where (k) is some arbitrary lag. A related concept, the <em>variogram</em> in spatial statistics, computes the variance of the difference between locations as they get further and further apart. The partial autocorrelation function (which relates the signal at (t) and (t-k) when accounting for all lags between), is also available in a geostatistical context by conditioning the variogram on adjacent pairs below the range. But, this is incredibly computationally intensive (and the variogram is sufficient for all kinds of geostatistical models), so the partial variant is much less well used.</p>
<p>Unfortunately, the <em>scale</em> of the US county system in terms of the distances between places gets much larger as we get west than when we are in the east. One way this is handled in spatial econometrics is to use the adjacency matrix to define neighborhoods. In this case, adjacent counties are considered neighbors, regardless of the actual distance between counties. This allows the connectivity graph relating observations to have a similar density when the polygons being related dilate but keep the same topology. I&rsquo;ll plot this graph over the counties below. Here, I use rook contiguity, which means two counties are adjacent if they share a boundary.</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>W = ps.weights.Rook.from_dataframe(votes)
</span></span><span style="display:flex;"><span>f = plt.figure(figsize=(<span style="color:#3677a9">1.6</span>*<span style="color:#3677a9">8</span>, <span style="color:#3677a9">8</span>))
</span></span><span style="display:flex;"><span>ax = plt.gca()
</span></span><span style="display:flex;"><span>votes.plot(linewidth=<span style="color:#3677a9">.1</span>, color=<span style="color:#ed9d13">&#39;white&#39;</span>, ax=ax)
</span></span><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">for</span> idx, neighbors <span style="color:#6ab825;font-weight:bold">in</span> W:
</span></span><span style="display:flex;"><span>    centroids = votes.ix[neighbors].geometry.apply(<span style="color:#6ab825;font-weight:bold">lambda</span> pgon: (pgon.centroid.x, pgon.centroid.y))
</span></span><span style="display:flex;"><span>    centroids = np.vstack(centroids.values)
</span></span><span style="display:flex;"><span>    focal = np.hstack(votes.ix[idx].geometry.centroid.xy)
</span></span><span style="display:flex;"><span>    <span style="color:#6ab825;font-weight:bold">for</span> neighbor <span style="color:#6ab825;font-weight:bold">in</span> centroids:
</span></span><span style="display:flex;"><span>        ax.plot(*<span style="color:#24909d">zip</span>(focal, neighbor), color=<span style="color:#ed9d13">&#39;firebrick&#39;</span>, linewidth=<span style="color:#3677a9">.1</span>)
</span></span><span style="display:flex;"><span>plt.xticks([])
</span></span><span style="display:flex;"><span>plt.yticks([])
</span></span><span style="display:flex;"><span>plt.title(<span style="color:#ed9d13">&#39;Rook Contiguity for US Counties&#39;</span>)
</span></span><span style="display:flex;"><span>plt.show()
</span></span></code></pre></div><p><img src="images/spacf_output_25_0.png" alt="png"></p>
<p>With this adjacency matrix, we can compute a few interesting spatial statistics. The first, the Bivariate Moran statistic (from <a href="dx.doi.org/10.1111/j.1538-4632.1985.tb00849.x">Wartenburg (1985)</a>, a kind of <a href="https://en.wikipedia.org/wiki/Mantel_test">Mantel statistic</a>), relates a set of observations to the <em>spatial lag</em> of another set of observations.</p>
<p>To be clear, the spatial lag is analogous to the temporal lag of a variate. In this case, the <em>spatial lag</em> refers to the average of the neighboring values around each observation. Using a row-standardized adjacency matrix (\mathbf{W}), the lag of (Y) is expressed simply as (\mathbf{W}Y).</p>
<p>This means that the bivariate Moran&rsquo;s I statistic is stated for centered attribute vectors (y) and (x):
\[ \frac{x&rsquo;\mathbf{W}y}{x&rsquo;x}\]</p>
<p>This results in a single statistic (and accompanying (p)-values computed using permutation methods) that relates the values of attribute (x) to the <em>lag</em> of (y). We can use this statistic to relate votes between two times. In the following, we see that county vote in the previous year is a good predictor of the vote in the next year:</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>bvi = ps.Moran_BV(votes[<span style="color:#ed9d13">&#39;tpv_2008&#39;</span>], votes[<span style="color:#ed9d13">&#39;tpv_2012&#39;</span>], w=W)
</span></span><span style="display:flex;"><span>bvi.I, bvi.p_sim
</span></span></code></pre></div><pre><code>(0.59905458256875777, 0.001)
</code></pre>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>bvi = ps.Moran_BV(votes[<span style="color:#ed9d13">&#39;tpv_2012&#39;</span>], votes[<span style="color:#ed9d13">&#39;tpv_2016&#39;</span>], w=W)
</span></span><span style="display:flex;"><span>bvi.I, bvi.p_sim
</span></span></code></pre></div><pre><code>(0.57711482669716285, 0.001)
</code></pre>
<p>Another way to look into this might be to look for clusters of volatility in how the vote changes betwen year to year. To do this, we&rsquo;ll be using the quadrants of the <a href="https://docs.google.com/presentation/d/1ePyu_eDvTUOp7jZc8XnTXbGEYexCGzd1mzpQ7gqksu8/edit#slide=id.g84b4ad007_0_113">Moran Scatterplot</a> to interpret local indicators that show whether some counties are swinging together with their neighbors, or if some counties are swinging in opposition to their neighbors. Moran statistics, computable in PySAL, allow us to determine both the relative direction (in terms of more or less Republican) and the neighborhood dynamics (in terms of how the nearby counties move). The local moran statistic for a vector of centered observations (z) is computed:</p>
<p>\[ I_i = \frac{z_i W_z z}{z&rsquo;z} \]</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>mli = ps.Moran_Local(votes.tpv_2016 - votes.tpv_2012, w=W)
</span></span><span style="display:flex;"><span>votes[<span style="color:#ed9d13">&#39;mlocal_1216&#39;</span>] = mli.Is
</span></span><span style="display:flex;"><span>votes[<span style="color:#ed9d13">&#39;mlocal_p_1216&#39;</span>] = mli.p_sim
</span></span><span style="display:flex;"><span>votes[<span style="color:#ed9d13">&#39;mlocal_quad_1216&#39;</span>] = mli.q
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>sns.distplot(mli.y)
</span></span><span style="display:flex;"><span>plt.title(<span style="color:#ed9d13">&#39;Change in two-party vote between 2012 and 2016&#39;</span>)
</span></span></code></pre></div><pre><code>/home/ljw/anaconda3/envs/py3/lib/python3.5/site-packages/statsmodels/nonparametric/kdetools.py:20: VisibleDeprecationWarning: using a non-integer number instead of an integer will result in an error in the future
  y = X[:m/2+1] + np.r_[0,X[m/2+1:],0]*1j





&lt;matplotlib.text.Text at 0x7f99eec38ac8&gt;
</code></pre>
<p><img src="images/spacf_output_31_2.png" alt="png"></p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>lmos = votes.sort_values([<span style="color:#ed9d13">&#39;mlocal_quad_1216&#39;</span>, <span style="color:#ed9d13">&#39;mlocal_p_1216&#39;</span>], ascending=<span style="color:#6ab825;font-weight:bold">False</span>)[[<span style="color:#ed9d13">&#39;county&#39;</span>, <span style="color:#ed9d13">&#39;STATE_NAME&#39;</span>,
</span></span><span style="display:flex;"><span>                                                                                 <span style="color:#ed9d13">&#39;tpv_2012&#39;</span>, <span style="color:#ed9d13">&#39;tpv_2016&#39;</span>,
</span></span><span style="display:flex;"><span>                                                                                   <span style="color:#ed9d13">&#39;mlocal_1216&#39;</span>,
</span></span><span style="display:flex;"><span>                                                                                   <span style="color:#ed9d13">&#39;mlocal_p_1216&#39;</span>, 
</span></span><span style="display:flex;"><span>                                                                                   <span style="color:#ed9d13">&#39;mlocal_quad_1216&#39;</span>,
</span></span><span style="display:flex;"><span>                                                                                   ]]
</span></span></code></pre></div><p>Then, we&rsquo;ll do some examination by the quadrant of the scatterplot. To make everything more clear, you might want to read this alongside <a href="https://docs.google.com/presentation/d/1ePyu_eDvTUOp7jZc8XnTXbGEYexCGzd1mzpQ7gqksu8/edit#slide=id.g84b4ad007_0_113">this plot</a>. We&rsquo;ll step by quadrant of that scatterplot:</p>
<h2 id="spatial-clusters-in-vote-swing">Spatial Clusters in Vote Swing</h2>
<h3 id="quadrant-i">Quadrant I</h3>
<p>Observations in quadrant I are counties where both the focal county and its neighbors had large increases in democratic vote share. These would represent counties where both the focal and its neighbors intensified in support for Democrats. Unsurprisingly, we see that the largest cluster strengths (in terms of the size of the <code>mlocal_1216</code> statistic) occur in Utah &amp; Virginia, states that were known to swing pretty strongly towards Clinton.</p>
<p>Surprises might be that Montgomery County, MD and those Georgia counties where Clinton was rumored to be surging in October show up here as well. Interestingly in some, cases (like the Utah counties or Georgia counties) this improvement is sometimes from <em>very</em> low (say 14% in Cache county, UT) to much better (30% in Cache county, UT). Thus, a lot of this is probably occuring among weak partisans who might be swayed by the (supposedly hefty) respectability bias about Trump, but who might otherwise vote Republican with a clear conscience.</p>
<p>And, unsurprisngly, you also see some consolidation going on, where county shifts towards the Democrats intensified in states typically won by Democrats, like the California counties in the list below.</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>(lmos.query(<span style="color:#ed9d13">&#39;mlocal_p_1216 &lt; .01 and mlocal_quad_1216 == 1&#39;</span>)
</span></span><span style="display:flex;"><span>   .sort_values([<span style="color:#ed9d13">&#39;mlocal_1216&#39;</span>], ascending=<span style="color:#6ab825;font-weight:bold">False</span>)
</span></span><span style="display:flex;"><span>   .head(<span style="color:#3677a9">25</span>))
</span></span></code></pre></div><!-- raw HTML omitted -->
<h3 id="quadrant-iii">Quadrant III</h3>
<p>On the opposite side of the origin in the Moran scatterplot, quadrant III would indicate &ldquo;low-low&rdquo; clusters, areas where the two-party vote decreased significantly in both the focal and neighboring units. Thus, these would be clusters of intensifying Republican support.</p>
<p>In these, you see precipitous drops in Democrat support in Missouri, Ohio, Iowa, and a cluster centered around Calhoun county, WV. This largely comports with the narrative that Ohio dropped out of being <em>truly</em> contested this cycle, with eventual vote totals falling well below the expected contestible range. Notably, this was <em>spatially correlated</em>, so not only did this affect counties in Ohio, but these clusters indicate that there was spillovers.</p>
<p>Like, for Monroe, Guernsey, Noble, Morgan County, OH, bordering WV, this analysis indicates that that group of counties swung <em>hard</em> towards the Republicans, and did so in a way that&rsquo;s statistically nonrandom in terms of the spatial location of those counties in Ohio. Notably <em>absent</em> from this are counties in the northwest of Ohio, abutting Michigan, that might indicate nascent spillovers between those states.</p>
<p>It also seems that heartland areas (Henderson county, IL, as well as the counties in southern Iowa and eastern MO, also swung together in a spatially-cluster for Trump.</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>(lmos.query(<span style="color:#ed9d13">&#39;mlocal_p_1216 &lt; .01 and mlocal_quad_1216 == 3&#39;</span>)
</span></span><span style="display:flex;"><span>   .sort_values([<span style="color:#ed9d13">&#39;mlocal_1216&#39;</span>], ascending=<span style="color:#6ab825;font-weight:bold">False</span>)
</span></span><span style="display:flex;"><span>   .head(<span style="color:#3677a9">25</span>))
</span></span></code></pre></div><!-- raw HTML omitted -->
<h3 id="quadrant-ii">Quadrant II</h3>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>(lmos.query(<span style="color:#ed9d13">&#39;mlocal_p_1216 &lt; .01 and mlocal_quad_1216 == 2&#39;</span>)
</span></span><span style="display:flex;"><span>   .sort_values([<span style="color:#ed9d13">&#39;mlocal_1216&#39;</span>], ascending=<span style="color:#6ab825;font-weight:bold">False</span>)
</span></span><span style="display:flex;"><span>   .head(<span style="color:#3677a9">25</span>))
</span></span></code></pre></div><!-- raw HTML omitted -->
<p>There aren&rsquo;t many observations in this quadrant. This indicates quadrants whose swing was more Republican than average while their neighbors&rsquo; swings were more <em>Democrat</em> than average. Note that this relates to the <em>mean national swing</em> as the unweighted average swing at the county level. So, this captues the counties who swung <em>more</em> Republican than average over counties <strong>while their neighbors swung more Democrat</strong> than average.</p>
<p>We see some pretty counter-iintuitive counties here. Linn county, OR and Lake county, CO weren&rsquo;t things that were on my radar, but it seems they&rsquo;ve moved anomalously towards the Republicans while their neighbors intensified in Democratic support.</p>
<h3 id="quadrant-iv">Quadrant IV</h3>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>(lmos.query(<span style="color:#ed9d13">&#39;mlocal_p_1216 &lt; .01 and mlocal_quad_1216 == 4&#39;</span>)
</span></span><span style="display:flex;"><span>   .sort_values([<span style="color:#ed9d13">&#39;mlocal_1216&#39;</span>], ascending=<span style="color:#6ab825;font-weight:bold">False</span>)
</span></span><span style="display:flex;"><span>   .head(<span style="color:#3677a9">25</span>))
</span></span></code></pre></div><!-- raw HTML omitted -->
<p>Like the second quadrant, these are also outliers. However, these are areas whose swings are more Democrat than average while their neighbors had swings that are more Republican than average. This seems to pick up a couple of Democratic areas where the general trend towards Trump failed to spill over between counties <em>as strongly</em> as it would have otherwise.</p>
<p>So, for example, Nicollet county, MN swung towards Trump at slightly more than the unweighted average shift towards Trump at the county level. But, this indicates its neighbors swung <em>even more strongly</em>.</p>
<p>To match this up, a map of the swing and the cluster statistics might be helpful. First, the swing map:</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>f,ax = plt.subplots(<span style="color:#3677a9">1</span>,<span style="color:#3677a9">1</span>,figsize=(<span style="color:#3677a9">1.6</span>*<span style="color:#3677a9">8</span>,<span style="color:#3677a9">8</span>))
</span></span><span style="display:flex;"><span>votes[<span style="color:#ed9d13">&#39;swing_1216&#39;</span>] = votes.tpv_2016 - votes.tpv_2012
</span></span><span style="display:flex;"><span>votes.plot(<span style="color:#ed9d13">&#39;swing_1216&#39;</span>, cmap=<span style="color:#ed9d13">&#39;RdBu&#39;</span>, ax=ax, linewidth=<span style="color:#3677a9">.1</span>, alpha=<span style="color:#3677a9">.8</span>)
</span></span><span style="display:flex;"><span>plt.title(<span style="color:#ed9d13">&#39;Swing in Two-Party vote in 2016&#39;</span>, fontsize=<span style="color:#3677a9">20</span>)
</span></span><span style="display:flex;"><span>plt.show()
</span></span></code></pre></div><p><img src="images/spacf_output_48_0.png" alt="png"></p>
<p>And then the cluster map:</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>votes[<span style="color:#ed9d13">&#39;stat_quad&#39;</span>] = votes.mlocal_quad_1216 * (votes.mlocal_p_1216&lt;<span style="color:#3677a9">.01</span>)
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>cp = sns.crayon_palette([<span style="color:#ed9d13">&#39;White&#39;</span>, <span style="color:#ed9d13">&#39;Cerulean&#39;</span>, <span style="color:#ed9d13">&#39;Tropical Rain Forest&#39;</span>, 
</span></span><span style="display:flex;"><span>                                 <span style="color:#ed9d13">&#39;Scarlet&#39;</span>, <span style="color:#ed9d13">&#39;Vivid Violet&#39;</span>])
</span></span><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">import</span> <span style="color:#447fcf;text-decoration:underline">matplotlib.colors</span> <span style="color:#6ab825;font-weight:bold">as</span> <span style="color:#447fcf;text-decoration:underline">cmaps</span>
</span></span><span style="display:flex;"><span>mymap, _ = cmaps.from_levels_and_colors(np.arange(-<span style="color:#3677a9">.5</span>,<span style="color:#3677a9">5.5</span>, <span style="color:#3677a9">1</span>), cp)
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>f,ax = plt.subplots(<span style="color:#3677a9">1</span>,<span style="color:#3677a9">1</span>,figsize=(<span style="color:#3677a9">1.6</span>*<span style="color:#3677a9">8</span>,<span style="color:#3677a9">8</span>))
</span></span><span style="display:flex;"><span>votes.plot(<span style="color:#ed9d13">&#39;stat_quad&#39;</span>, linewidth=<span style="color:#3677a9">.1</span>, cmap=mymap, ax=ax, alpha=<span style="color:#3677a9">.7</span>)
</span></span><span style="display:flex;"><span>ax.set_xticklabels([])
</span></span><span style="display:flex;"><span>ax.set_yticklabels([])
</span></span><span style="display:flex;"><span>plt.title(<span style="color:#ed9d13">&#39;Local Indicators of Partisan Swing&#39;</span>, fontsize=<span style="color:#3677a9">20</span>)
</span></span><span style="display:flex;"><span>plt.show()
</span></span><span style="display:flex;"><span>sns.palplot(cp, size=<span style="color:#3677a9">1.5</span>)
</span></span><span style="display:flex;"><span>plt.show()
</span></span><span style="display:flex;"><span><span style="color:#24909d">print</span>(<span style="color:#ed9d13">&#39;NSD from Mean   Dem Cluster   Rep Outlier   Rep Cluster   Dem Outlier&#39;</span>)
</span></span></code></pre></div><p><img src="images/spacf_output_52_0.png" alt="png"></p>
<p><img src="images/spacf_output_52_1.png" alt="png"></p>
<pre><code>NSD from Mean   Dem Cluster   Rep Outlier   Rep Cluster   Dem Outlier
</code></pre>
<p>More specifically for these labels:</p>
<ol>
<li><code>NSD from Mean</code>: swing is about the national average in both the neighboring counties and the focal county.</li>
<li><code>Dem Cluster</code>: Swing is better for Democrats in both the focal and the neighboring counties than it is nationally. <em>(Dems overperform in this spatial cluster)</em></li>
<li><code>Rep Outlier</code>: Swing is better for Republicans in this county than it is nationally <strong>and</strong> better for Democrats in neighboring counties than it is nationally <em>(Reps overperform in this county vs. nearby counties and the nation)</em></li>
<li><code>Rep Cluster</code>: Swing is better for Republicans in this county and the neighboring counties than it is nationally <em>(Reps overperform in this spatial cluster)</em></li>
<li><code>Dem Outlier</code>: Swing is better for Democrats in this county than nationally, but better for Republicans in neighboring counties than nationally <em>(Dems overperform in this county vs. nearby counties and the nation)</em></li>
</ol>
<h1 id="gauging-typical-cluster-size">Gauging typical Cluster size</h1>
<p>With this, we can try to identify the &ldquo;range&rdquo; at which counties are related to one another. If we can identify this, we might be able to tell the graph distance at which counties tend to be come uncorrelated with one another.</p>
<p>To compute this, we can use the (partial) spatial autocorrelation functions to identify this. In a similar manner to the (partial) temporal autocorrelation function, the (partial) spatial autocorrelation function relates each observation to its (k)th order neighbors. In the spatial context, the (k)th order neighbors of observation (y_i) is the set of observations (y_j) that are <em>first</em> reached in (k) steps. This means that the graph distance between observation (y_j) and (y_i) is exactly (k):
\[ {y_{ik}  : min(||y_j - y_i||) = k ~ ~ ~ ~ ~ ~ \forall j= 1, 2, \dots, n}\]
Thus, the (k)th order spatial autocorrelation function is:</p>
<p>\[\rho_k = cor(y, \mathbf{W}^ky)\]</p>
<p>where (\mathbf{W}^k) is the adjacency matrix for (k)-minimal neighbors. The (k)th-order <em>partial</em> spatial autocorrelation function is:</p>
<p>\[ \dot{\rho}_k = cor(y, \mathbf{W}^ky <del>|</del> \mathbf{W}^{k-1}y, \mathbf{W}^{k-2}y, \dots, \mathbf{W}^{1}y )\]</p>
<p>I plot these for the vote shares in 2016 below,</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">import</span> <span style="color:#447fcf;text-decoration:underline">spacf</span>
</span></span></code></pre></div><p>First, the full spatial autocorrelation plot:</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>lags = spacf.spacf(votes[[<span style="color:#ed9d13">&#39;tpv_2016&#39;</span>]].values - votes[[<span style="color:#ed9d13">&#39;tpv_2012&#39;</span>]].values,W, order=<span style="color:#3677a9">20</span>)
</span></span><span style="display:flex;"><span>plt.figure(figsize=(<span style="color:#3677a9">1.6</span>*<span style="color:#3677a9">4</span>*<span style="color:#3677a9">2</span>,<span style="color:#3677a9">4</span>))
</span></span><span style="display:flex;"><span>plt.plot(lags, linewidth=<span style="color:#3677a9">5</span>, color=<span style="color:#ed9d13">&#39;slategrey&#39;</span>)
</span></span><span style="display:flex;"><span>plt.title(<span style="color:#ed9d13">&#39;Spatial ACF&#39;</span>, fontsize=<span style="color:#3677a9">20</span>)
</span></span><span style="display:flex;"><span>plt.hlines(<span style="color:#3677a9">0</span>,<span style="color:#3677a9">0</span>,<span style="color:#24909d">len</span>(lags), linestyle=<span style="color:#ed9d13">&#39;:&#39;</span>, color=<span style="color:#ed9d13">&#39;k&#39;</span>)
</span></span><span style="display:flex;"><span>plt.axis([<span style="color:#3677a9">0</span>,<span style="color:#3677a9">25</span>,-<span style="color:#3677a9">.2</span>,<span style="color:#3677a9">1</span>])
</span></span><span style="display:flex;"><span>plt.show()
</span></span></code></pre></div><p><img src="images/spacf_output_58_0.png" alt="png"></p>
<p>Interpreting this, we have to move around 16 counties out before the autocorrelation between counties becomes negative. Remember, this statistic considers only (k)-minimal neighbors, not all observations below (k)th order neighbors. If you don&rsquo;t consider (k)-minimal neighbors (rather than (k)th order), then sets of higher-order neighbors will contain the set of lower-order neighbors.</p>
<p>In a time series context, this would be akin to considering both the observation from 2 periods ago <em>and</em> the previous observation in the set of 2nd order neighbors. In contrast, this graph shows the correlation as the set of &ldquo;considered&rdquo; counties radiates uniformly outwards from each focal county.</p>
<p>Thus, a typical ``cluster&rsquo;&rsquo; in the sense of counties being more related to each other than not, is a subgraph somewhere south of 15-counties in radius. If this seems too big to you, you&rsquo;re right. We need to account for the <em>whole</em> neighborhood contained with the (k)-radius cluster:</p>
<h3 id="conditional-width-of-cluster-size">Conditional width of cluster size</h3>
<p>The partial correlation plot <em>does</em> condition on the neighbors below (k)-th order. So, the correlation between the (k)-minimal neighbors and the source observations is conditional on 1st through (k-1)-minimal neighbors. We can use this plot to adequately identify the ``order&rsquo;&rsquo; of the spatial process, if we treat it as a spatial markov random field.</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>plags = spacf.sppacf(votes[[<span style="color:#ed9d13">&#39;tpv_2016&#39;</span>]].values -votes[[<span style="color:#ed9d13">&#39;tpv_2012&#39;</span>]].values , W, order=<span style="color:#3677a9">10</span>)
</span></span><span style="display:flex;"><span>plt.figure(figsize=(<span style="color:#3677a9">1.6</span>*<span style="color:#3677a9">4</span>,<span style="color:#3677a9">4</span>))
</span></span><span style="display:flex;"><span>plt.plot(plags, linewidth=<span style="color:#3677a9">5</span>, color=<span style="color:#ed9d13">&#39;slategrey&#39;</span>)
</span></span><span style="display:flex;"><span>plt.title(<span style="color:#ed9d13">&#39;Partial Spatial ACF&#39;</span>)
</span></span><span style="display:flex;"><span>plt.hlines(<span style="color:#3677a9">0</span>,<span style="color:#3677a9">0</span>,<span style="color:#24909d">len</span>(plags), linestyle=<span style="color:#ed9d13">&#39;:&#39;</span>, color=<span style="color:#ed9d13">&#39;k&#39;</span>)
</span></span><span style="display:flex;"><span>plt.show()
</span></span></code></pre></div><p><img src="images/spacf_output_62_0.png" alt="png"></p>
<p>Interpreting this, we see that the first order neighbors are typically sufficient to capture the full extent of correlation between counties. Conditional on the first-order neighbors, higher-order neighbor correlation pretty-much disappears..</p>

    </div>

    
<ul class="list-none pl-0 font-sm align-left">


<li class="list-none">
    Tags:
    
    <a class="inline-block mt-2 mr-2 border-none text-neutral-800 dark:text-neutral-200"
       href="/tags/spatial-autocorrelation">
        <span class="flex flex-row justify-start items-center
                     dark:bg-zinc-900 dark:hover:bg-zinc-700
                     hover:bg-zinc-300 bg-zinc-200
                     dark:border-zinc-600 py-0.5
                     px-1 rounded-t border-b-2 border-zinc-300
                     hover:border-zinc-500">
            
            <img class="h-4 mr-2 inline" src="https://ljwolf.org/images/tag_logo.svg"
                 alt="Logo of a tag: indicates that a tag item follows.">
            spatial autocorrelation
        </span>
    </a>
    
    <a class="inline-block mt-2 mr-2 border-none text-neutral-800 dark:text-neutral-200"
       href="/tags/esda">
        <span class="flex flex-row justify-start items-center
                     dark:bg-zinc-900 dark:hover:bg-zinc-700
                     hover:bg-zinc-300 bg-zinc-200
                     dark:border-zinc-600 py-0.5
                     px-1 rounded-t border-b-2 border-zinc-300
                     hover:border-zinc-500">
            
            <img class="h-4 mr-2 inline" src="https://ljwolf.org/images/tag_logo.svg"
                 alt="Logo of a tag: indicates that a tag item follows.">
            esda
        </span>
    </a>
    
    <a class="inline-block mt-2 mr-2 border-none text-neutral-800 dark:text-neutral-200"
       href="/tags/dissertation">
        <span class="flex flex-row justify-start items-center
                     dark:bg-zinc-900 dark:hover:bg-zinc-700
                     hover:bg-zinc-300 bg-zinc-200
                     dark:border-zinc-600 py-0.5
                     px-1 rounded-t border-b-2 border-zinc-300
                     hover:border-zinc-500">
            
            <img class="h-4 mr-2 inline" src="https://ljwolf.org/images/tag_logo.svg"
                 alt="Logo of a tag: indicates that a tag item follows.">
            dissertation
        </span>
    </a>
    
    <a class="inline-block mt-2 mr-2 border-none text-neutral-800 dark:text-neutral-200"
       href="/tags/swing">
        <span class="flex flex-row justify-start items-center
                     dark:bg-zinc-900 dark:hover:bg-zinc-700
                     hover:bg-zinc-300 bg-zinc-200
                     dark:border-zinc-600 py-0.5
                     px-1 rounded-t border-b-2 border-zinc-300
                     hover:border-zinc-500">
            
            <img class="h-4 mr-2 inline" src="https://ljwolf.org/images/tag_logo.svg"
                 alt="Logo of a tag: indicates that a tag item follows.">
            swing
        </span>
    </a>
    
    <a class="inline-block mt-2 mr-2 border-none text-neutral-800 dark:text-neutral-200"
       href="/tags/elections">
        <span class="flex flex-row justify-start items-center
                     dark:bg-zinc-900 dark:hover:bg-zinc-700
                     hover:bg-zinc-300 bg-zinc-200
                     dark:border-zinc-600 py-0.5
                     px-1 rounded-t border-b-2 border-zinc-300
                     hover:border-zinc-500">
            
            <img class="h-4 mr-2 inline" src="https://ljwolf.org/images/tag_logo.svg"
                 alt="Logo of a tag: indicates that a tag item follows.">
            elections
        </span>
    </a>
    
</li>

</ul>


    

    
    <div class="text-neutral-500 mb-4">
        Last modified <span itemprop="dateModified"
                            datetime="2018-03-09T17:34:20Z"
                            content="2018-03-09T17:34:20Z">
        2018.03.09
        </span>
    </div>
    
</article>

    </main>
    <footer class="footer container h-10 text-center mt-1">
<hr class="my-4">
  <ul class="pl-0 mt-1">
    
    <li class="ml-2 first:before:content-none before:content-['•']
               inline-block list-none">
      <a class="ml-2 text-neutral-800
                dark:text-neutral-400 border-none"
          href="https://github.com/hugcis/hugo-astatine-theme">Code</a>
    </li>
    <li class="ml-2 first:before:content-none before:content-['•']
                text-neutral-800 dark:text-neutral-400 inline-block list-none">
      <span class="ml-2">© Levi John Wolf 2025</span>
    </li>
  </ul>
</footer>



  </body>
</html>
